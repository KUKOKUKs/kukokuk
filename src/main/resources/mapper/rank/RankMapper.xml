<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.kukokuk.domain.rank.mapper.RankMapper">

    <!-- 랭크 조회용 resultMap -->
    <resultMap id="RankResultMap" type="Rank">
        <id property="rankNo" column="RANK_NO"/>
        <result property="contentType" column="CONTENT_TYPE"/>
        <result property="playCount" column="PLAY_COUNT"/>
        <result property="totalScore" column="TOTAL_SCORE"/>
        <result property="rankMonth" column="RANK_MONTH"/>
        <result property="userNo" column="USER_NO"/>
        <result property="createdDate" column="CREATED_DATE"/>
        <result property="updatedDate" column="UPDATED_DATE"/>

        <result property="userRank" column="USER_RANK"/>

        <result property="nickname" column="NICKNAME"/>
        <result property="level" column="LEVEL"/>
        <result property="profileFilename" column="PROFILE_FILENAME"/>
    </resultMap>

    <!--
         * 랭킹 등록
         * @param rank 랭킹 정보
        void insertRank(Rank rank);
    -->
    <insert id="insertRank" parameterType="Rank">
        INSERT INTO KUKOKUK_RANKS( CONTENT_TYPE
                                 , PLAY_COUNT
                                 , TOTAL_SCORE
                                 , RANK_MONTH
                                 , USER_NO)
        VALUES ( #{contentType}
               , #{playCount}
               , #{totalScore}
               , #{rankMonth}
               , #{userNo})
    </insert>

    <!--
         * 기존 랭킹 업데이트 (점수, 플레이 횟수/조정된 값)
         * @param rank 업데이트할 랭킹 정보
        void updateRank(Rank rank);
    -->
    <update id="updateRank" parameterType="Rank">
        UPDATE KUKOKUK_RANKS
        SET PLAY_COUNT  = #{playCount}
          , TOTAL_SCORE = #{totalScore}
        WHERE RANK_NO = #{rankNo}
          AND USER_NO = #{userNo}
    </update>

    <!--
         * 특정 월, 컨텐츠타입의 사용자 랭크 조회
         * @param rankRequestDto contentType, rankMonth, userNo
         * @return 사용자의 랭크 정보
        Rank getContentRankByUserNo(RankRequestDto rankRequestDto);
    -->
    <select id="getContentRankByUserNo" parameterType="RankRequestDto" resultMap="RankResultMap">
        SELECT RANK_NO
             , CONTENT_TYPE
             , PLAY_COUNT
             , TOTAL_SCORE
             , RANK_MONTH
             , USER_NO
             , CREATED_DATE
             , UPDATED_DATE
        FROM KUKOKUK_RANKS
        WHERE USER_NO = #{userNo}
          AND RANK_MONTH = #{rankMonth}
          AND CONTENT_TYPE = #{contentType}
    </select>

    <!--
         * 조건에 해당하며 사용자 랭크를 포함한 목록 조회
         * <p>
         *     정확한 데이터를 가져오기 위해 RANK() 사용으로 limit 개수 보다 많을 수 있음
         *     서비스단에서 가공 필요
         * @param rankRequestDto contentType, rankMonth, userNo, limit
         * @return 랭크 목록 정보(userRank 정렬)
        List<Rank> getContentRanksIncludeUserByMonth(RankRequestDto rankRequestDto);
    -->
    <select id="getContentRanksIncludeUserByMonth" parameterType="RankRequestDto" resultMap="RankResultMap">
        <![CDATA[
        SELECT *
        FROM (SELECT R.RANK_NO
                   , R.CONTENT_TYPE
                   , R.PLAY_COUNT
                   , R.TOTAL_SCORE
                   , R.RANK_MONTH
                   , R.USER_NO
                   , R.CREATED_DATE
                   , R.UPDATED_DATE
                   , U.NICKNAME
                   , U.LEVEL
                   , U.PROFILE_FILENAME
                   -- RANK 계산 주요 기준은 TOTAL_SCORE DESC.
                   -- 동점(같은 TOTAL_SCORE) 상황에서 deterministic(결정적) 순서를 만들기 위해
                   -- 추가 정렬키(PLAY_COUNT DESC, UPDATED_DATE ASC, RANK_NO ASC)를 설정
                   , RANK() OVER (PARTITION BY R.CONTENT_TYPE, R.RANK_MONTH
                       ORDER BY R.TOTAL_SCORE DESC, R.PLAY_COUNT DESC, R.UPDATED_DATE, R.RANK_NO) AS USER_RANK
              FROM KUKOKUK_RANKS R
                       JOIN KUKOKUK_USERS U ON R.USER_NO = U.USER_NO
              WHERE R.CONTENT_TYPE = #{contentType}
                AND R.RANK_MONTH = #{rankMonth}) AS SUB
        -- 상위 limit과 (limit 밖일 때의) 사용자 행 둘 다 가져오기
        WHERE USER_RANK <= #{limit}
           OR (USER_NO = #{userNo} AND USER_RANK > #{limit})
        ORDER BY USER_RANK, RANK_NO
        ]]>
    </select>

    <!--
         * 조건에 해당하며 사용자 랭크를 포함한 그룹 랭크 목록 조회
         * @param rankRequestDto groupNo, contentType, rankMonth, userNo, limit
         * @return 그룹 랭크 목록 정보(userRank 정렬)
        List<Rank> getGroupContentRanksIncludeUserByMonth(RankRequestDto rankRequestDto);
    -->
    <select id="getGroupContentRanksIncludeUserByMonth" parameterType="RankRequestDto" resultMap="RankResultMap">
        <![CDATA[
        SELECT *
        FROM (SELECT R.RANK_NO
                   , R.CONTENT_TYPE
                   , R.PLAY_COUNT
                   , R.TOTAL_SCORE
                   , R.RANK_MONTH
                   , R.USER_NO
                   , R.CREATED_DATE
                   , R.UPDATED_DATE
                   , U.NICKNAME
                   , U.LEVEL
                   , U.PROFILE_FILENAME
                   , RANK() OVER (PARTITION BY R.CONTENT_TYPE, R.RANK_MONTH ORDER BY R.TOTAL_SCORE DESC) AS USER_RANK
              FROM KUKOKUK_RANKS R
                       JOIN KUKOKUK_USERS U ON R.USER_NO = U.USER_NO
                       JOIN KUKOKUK_GROUP_USERS GU ON U.USER_NO = GU.USER_NO
              WHERE GU.GROUP_NO = #{groupNo}
                AND R.CONTENT_TYPE = #{contentType}
                AND R.RANK_MONTH = #{rankMonth}) AS SUB
        WHERE USER_RANK <= #{limit}
           OR (USER_NO = #{userNo} AND USER_RANK > #{limit}) -- 기본 랭크 목록에 포함되어 있지 않을 수 있으므로
        ORDER BY USER_RANK
        ]]>
    </select>

    <!--
     * 레벨 기준 사용자를 포함한 상위 랭크 목록 조회
     * <p>
     *     날짜 상관없이 레벨과 경험치로만 정렬
     *     정확한 데이터를 가져오기 위해 RANK() 사용으로 limit 개수 보다 많을 수 있음
     *     서비스단에서 가공 필요
     * @param rankRequestDto userNo, limit
     * @return 레벨 랭크 목록 정보(level DESC, experiencePoints DESC 정렬)
    List<Rank> getLevelRanksIncludeUser(RankRequestDto rankRequestDto);
-->
    <select id="getLevelRanksIncludeUser" parameterType="RankRequestDto" resultMap="RankResultMap">
    <![CDATA[
        SELECT *
        FROM (SELECT U.USER_NO
                   , U.NICKNAME
                   , U.LEVEL
                   , U.PROFILE_FILENAME
                   , U.EXPERIENCE_POINTS
                   , RANK() OVER (ORDER BY U.LEVEL DESC, U.EXPERIENCE_POINTS DESC, U.USER_NO) AS USER_RANK
              FROM KUKOKUK_USERS U) AS SUB
        WHERE USER_RANK <= #{limit}
           OR (USER_NO = #{userNo} AND USER_RANK > #{limit})
        ORDER BY USER_RANK, USER_NO
        ]]>
</select>
</mapper>